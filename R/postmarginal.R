#' Illustration of postmarginal()
#'
#' This function allows to estimate posterior probability with a null marginal effect size and posterior mean of marginal effect size. 
#' @param summarydata either summay-level GWAS data, containing 3 columns:
#' SNP (SNP rsID), 
#' Z (GWAS test z-statistic), 
#' N (GWAS study sample size which can be different for different SNPs)
#' or a dataframe generated by preprocessing() function which allows the summarydata to merge with LD score information and contains 10 columns. 
#' @param est parameter estimates by fitting either 2-component model, i.e., (pic, sigmasq, a); or 3-component model, i.e., (pic, p1, sigmasq1, sigmasq2, a).
#' @param c0 an assumed maximum number of underlying susceptibility SNPs tagged by any individual GWAS marker. By default, c0 is set at 10.
#' @param LDcutoff a number from (0.05, 0.1, 0.2); indicating LD score is calculated based on the particular cutoff. By default, it is 0.1.
#' @param LDwindow a number from (0.5, 1, 2); indicating LD score is calculated based on the particular window size (MB). By default, it is 1 MB.
#' @param filter logical; if TRUE, the input summary data will be filtered.
#' @keywords 
#' @export
#' @examples postmarginal(summarydata,est, c0=10, LDcutoff=0.1, LDwindow=1, filter=F)
#' 
postmarginal <- function(summarydata, est, c0=10, LDcutoff=0.1, LDwindow=1, filter=F){
  
  #----------------------------------------------------
  # I. summary GWAS data format check
  #----------------------------------------------------
  # (i) the input summarydata is the original summary lelve GWAS data, containing 3 columns: 
  # SNP (SNP rsID), Z (GWAS test z-statistic), N (GWAS study sample size which can be different for different SNPs)
  if(ncol(summarydata)==3){
    df <- preprocessing(summarydata, LDcutoff,LDwindow,filter)
  }
  
  # (ii) the input summarydata is already merged with the LD score data, thus no processing 
  if(ncol(summarydata)==10){
    df <- summarydata
  }
  
  betahat <- as.numeric(as.character(df$betahat))
  varbetahat <- as.numeric(as.character(df$varbetahat))
  ldscore <- as.numeric(as.character(df$LD.score.correct))
  Nstar <- as.numeric(as.character(df$Nstar))
  SNP <- df$SNP
  TaggingSNPs <- df$TaggingSNPs
  K <- length(betahat)
  n <- as.numeric(as.character(df$N))
  
  #----------------------------------------------------
  # II. posterior marginal effect size 
  #----------------------------------------------------
  if(length(est)==3) components=2
  if(length(est)==5) components=3
  
  if(components==2){
    q0 = (1-est[1])^Nstar * 1/sqrt(2*pi*(varbetahat)) * exp(-0.5*betahat^2/(varbetahat))
    beta_exp = 0 # posterior expectation of marginal effect size (zero when Nk0=Nstar)
    # each SNP has a different N_k^*, therefore goes thru different number of loops.
    qsum = q0
    for (i in 1:c0){ # i is Nk1: first type of causal marker
      # print(i)
      qtemp = rep(0, length(Nstar))
      delta = i*est[2]*ldscore/Nstar 
      ind = Nstar>=i
      
      qtemp[ind] = choose(Nstar[ind],i) * 
        (1-est[1])^(Nstar[ind]-i)*(est[1]^i) / sqrt(2*pi*(delta[ind]+varbetahat[ind])) *
        exp(-0.5*betahat[ind]^2/(delta[ind]+varbetahat[ind]))
      
      qsum = qsum + qtemp # Summation of q's the denominator
      beta_exp = beta_exp + qtemp * (varbetahat)^(-1)*betahat/(1/delta+(varbetahat)^(-1))
    }
    
    p_beta0 = q0 / qsum
    beta_exp = beta_exp / qsum
    
  }
  
  if(components==3){
    q0 = (1-est[1])^Nstar * 1/sqrt(2*pi*(varbetahat)) * exp(-0.5*betahat^2/(varbetahat))
    beta_exp = 0 # posterior expectation of marginal effect size (zero when Nk0=Nstar)
    # each SNP has a different N_k^*, therefore goes thru different number of loops.
    qsum = q0
    for (i in 0:c0){ # i is Nk1: number of the first type of causal SNPs
      # print(i)
      for (j in 0:c0){ # j is Nk2: number of the second type of causal SNPs
        if (i==0 & j==0){
          next
        } else{
          # print(paste(i,j))
          qtemp = rep(0, length(Nstar))
          delta = (i*est[3]+j*est[4])*ldscore/Nstar 
          ind = Nstar>=(i+j)
          
          qtemp[ind] = choose(Nstar[ind],i)*choose(Nstar[ind]-i,j) * 
            ((1-est[1])^(Nstar[ind]-i-j))*((est[2]*est[1])^i)*(((1-est[2])*est[1]))^j * 1/sqrt(2*pi*(delta[ind]+varbetahat[ind])) *
            exp(-0.5*betahat[ind]^2/(delta[ind]+varbetahat[ind]))
          
          qsum = qsum + qtemp # Summation of q's the denominator
          beta_exp = beta_exp + qtemp * (varbetahat)^(-1)*betahat/(1/delta+(varbetahat)^(-1))
        }
      }
    }
    p_beta0 = q0 / qsum
    beta_exp = beta_exp / qsum
  }
  posterior = list()
  posterior$snp = SNP
  posterior$prob.beta0 = p_beta0
  posterior$posteriormean.marginal = beta_exp
  return(posterior)
}
