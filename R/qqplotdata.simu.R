#' Illustration of qqplotdata.simu()
#'
#' This function allows to generate expected p-values under the fitted model through simulations, hence then get the dataframe to generate qqplot.
#' @param summarydata either summay-level GWAS data, containing 3 columns:
#' SNP (SNP rsID), 
#' Z (GWAS test z-statistic), 
#' N (GWAS study sample size which can be different for different SNPs)
#' or a dataframe generated by preprocessing() function which allows the summarydata to merge with LD score information and contains 10 columns. 
#' @param est parameter estimates by fitting either 2-component model, i.e., (pic, sigmasq, a); or 3-component model, i.e., (pic, p1, sigmasq1, sigmasq2, a).
#' @param c0 an assumed maximum number of underlying susceptibility SNPs tagged by any individual GWAS marker. By default, c0 is set at 10.
#' @param qqplotCI.coverage the coverage rate of confidence band in the QQ plot. By default, it is 0.8.
#' @param qqplot.nsim the total number of simulations to generate the expected p-values to get the QQ plot. By default, it is 100.
#' @param LDcutoff a number from (0.05, 0.1, 0.2); indicating LD score is calculated based on the particular r^2 cutoff. By default, it is 0.1.
#' @param LDwindow a number from (0.5, 1, 2); indicating LD score is calculated based on the particular window size (MB). By default, it is 1 MB.
#' @param filter logical; if TRUE, the input summary data will be filtered.
#' @param cores number of CPU threads in parallel computing; by default, it is 1. 
#' @param seeds numeric random seeds used in simulation; by default, it is 123. 
#' @keywords 
#' @export
#' @examples qqplotdata.simu(summarydata, est, c0=10, qqplotCI.coverage=0.8, qqplot.nsim=100, LDcutoff=0.1, LDwindow=1, filter=F,cores=1,seeds=123)

qqplotdata.simu <- function(summarydata, est, c0=10,
                            qqplotCI.coverage=0.8, qqplot.nsim=100, 
                            LDcutoff=0.1, LDwindow=1, filter=F,cores=1,seeds=123){
  
  # load the required R package
  library(doParallel)
  library(foreach)
  cl <- makeCluster(cores)  
  registerDoParallel(cl)  
  
  if(length(est)==3) modelcomponents=2
  if(length(est)==5) modelcomponents=3
  
  #----------------------------------------------------#----------------------------------------------------
  # I. summary GWAS data format check
  #----------------------------------------------------#----------------------------------------------------
  # (i) the input summarydata is the original summary lelve GWAS data, containing 3 columns: 
  # SNP (SNP rsID), Z (GWAS test z-statistic), N (GWAS study sample size which can be different for different SNPs)
  if(ncol(summarydata)==3){
    df <- preprocessing(summarydata, LDcutoff,LDwindow,filter)
  }
  
  # (ii) the input summarydata is already merged with the LD score data, thus no processing 
  if(ncol(summarydata)==10){
    df <- summarydata
  }
  
  #----------------------------------------------------#----------------------------------------------------
  # II. extract the variables needed for analysis
  #----------------------------------------------------#----------------------------------------------------
  betahat <- as.numeric(as.character(df$betahat))
  varbetahat <- as.numeric(as.character(df$varbetahat))
  ldscore <- as.numeric(as.character(df$LD.score.correct))
  Nstar <- as.numeric(as.character(df$Nstar))
  SNPsum <- df$SNP
  K <- length(betahat)
  n <- as.numeric(as.character(df$N))

  obs_z <- betahat/sqrt(varbetahat)
  obs_pvalues <- 2*pnorm(-abs(obs_z))
  obs_lambda <- median(obs_z^2)/qchisq(0.5,1)
  log_obs_pvalues <- -log10(obs_pvalues)
  log_obs_pvalues <- sort(log_obs_pvalues)
  
  data(list=paste0("error_iter1")); error.snplist = SNP; SNP = SNPsum

  #----------------------------------------------------#----------------------------------------------------
  # III. get the simulated p-values under the fitted model (needed for getting the expected p-values in qqplot)
  #----------------------------------------------------#----------------------------------------------------
  if(modelcomponents == 2){
    a <- est[3]; if(a<0) a <- 0; 
    te <- mixture_components_marginal(est, ldscore, c0, Nstar, cores)
  }
  
  if(modelcomponents == 3){
    a <- est[5]; if(a<0) a <- 0; 
    te <- mixture_3components_marginal(est, ldscore, c0, Nstar, cores)
  }
  
  proportions <- te$proportions
  varcomponents <- te$varcomponents
  L <- ncol(proportions)
  
  # ------------------------------------------------
  # initializing the expected z and p-values 
  log_exp_pvalues <- matrix(0,qqplot.nsim,K);
  exp_z <- matrix(0,qqplot.nsim,K)
  exp_lambda <- rep(0,qqplot.nsim)
  temorder <- order(match(error.snplist, SNP))
  
  # ------------------------------------------------
  foreach(i=1:qqplot.nsim)%do%{
    data(list=paste0("error_iter",i))
    set.seed(seeds*i)
    # ------------------------------------------------
    # get the marginal effect size under the fitted model
    betamarginal <- rep(0,K)
    for(k in 1:K){
      components <- sample(1:L, prob=proportions[k,],size=1, replace=T)
      mus <- rep(0, L)
      sds <- sqrt(varcomponents[k,])
      betamarginal[k] <- rnorm(n=1,mean=mus[components],sd=sds[components])
    }
    
    betahat <- betamarginal + error[temorder][1:K] /sqrt(n) + rnorm(1,mean=0,sd=sqrt(a))
    exp_z[i,] <- betahat*sqrt(n)
    log_exp_pvalues[i,] <- -log10(2*pnorm( -abs(exp_z[i,])) )
    exp_lambda[i] <- median(exp_z[i,]^2)/qchisq(0.5,1)
    log_exp_pvalues[i,] <- sort(log_exp_pvalues[i,])
  }

  mean_log_exp_pvalues <- apply(log_exp_pvalues, 2, mean) 
  lower <- apply(log_exp_pvalues, 2, function(t) quantile(t, (1-qqplotCI.coverage)/2)) 
  upper <- apply(log_exp_pvalues, 2, function(t) quantile(t, 1-(1-qqplotCI.coverage)/2))
  
  m.lambda <- mean(exp_lambda);
  l.lambda <- quantile(exp_lambda, (1-qqplotCI.coverage)/2)
  h.lambda <- quantile(exp_lambda, 1-(1-qqplotCI.coverage)/2)
  
  QQdata = data.frame(cbind(log_obs_pvalues,mean_log_exp_pvalues,lower,upper))
  # colnames(QQdata) = c("log10(observed pvalues)", "expected log10(fitted pvalues)", "lower bound of log10(fitted pvalues)","upper bound of log10(fitted pvalues)" )
  
  qqplotdata <- list(QQdata=QQdata, observedlambda=obs_lambda,
                     meanEXPlambda=m.lambda, lowEXPlambda=l.lambda, highEXPlambda=h.lambda)
  
  return(qqplotdata)
}